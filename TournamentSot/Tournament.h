#pragma once

//@author Мирошин В.И.
//Файл с методом туринроной сортировки
#include <algorithm>
#include <iostream>
#include "climits"
using namespace std;

//Турнирная сортировка массива
void tournamentSort(int arr[], int n)
{
    //Определение размера дерева для турнирной сортировки
    //Дерево должно быть полным, т.е. количество узлов равно какой-то степени двойки
    int treeSize = 1;
    while (treeSize <= n) {
        treeSize *= 2;
    }

    //Создание динамического массива размерностью, равной количеству узлов в дереве * 2
    int size = (2 * treeSize);
    int* tree = new int[size];

    //Каждому узлу присвоить значение максимального для данного типа данных (int)
    for (int i = 0; i < size; i++) {
        tree[i] = INT_MAX;
    }

    //Присвоить элементы массива второй половине дерева
    for (int i = 0; i < n; i++) {
        tree[treeSize + i] = arr[i];
    }

    //Сортировка путём выбора минимального элемента из каждой пары чисел
    //Начинаем с нижнего уровня дерева
    for (int i = treeSize - 1; i >= 1; i--) {
        //Родителю присваивается наименьшее из его потомков
        tree[i] = min(tree[2 * i], tree[2 * i + 1]);
    }

    //Достаём элементы из дерева в возрастающем порядке
    int sortIndex = 0;
    //Пока не запишем в массив все элементы
    while (sortIndex < n) {

        //Присвоение корня исходному массиву (т.е. минимального элемента)
        arr[sortIndex] = tree[1];

        //Увеличиваем счётчик записанных элементов отсортированного массива на 1
        sortIndex++;

        //Присвоение корню максимального значения для int
        //INT_MAX - это макрос, который указывает, что целочисленная переменная не может хранить какое-либо значение сверх этого предела
        tree[1] = INT_MAX;


        //Индекс первого узла
        int node = 1;
        //В данном цикле из tree удаляются все дубликаты узла, который уже достали из корня в исходный массив
        while (node < treeSize) {
            int leftChild = 2 * node;
            int rightChild = 2 * node + 1;

            //Находим индекс наименьшего узла из потомков
            if (tree[leftChild] < tree[rightChild]) {
                node = leftChild;
            }
            else {
                node = rightChild;
            }

            //Этому наименьшему узлу присваиваем максимальное значение для int
            tree[node] = INT_MAX;

        }

        //Выбор минимального элемента из каждой пары чисел
        for (int i = treeSize - 1; i >= 1; i--) {
            //Родителю присваивается наименьшее из его потомков
            tree[i] = min(tree[2 * i], tree[2 * i + 1]);
        }
    }
    //Удаление родиеля
    delete[] tree;
}
